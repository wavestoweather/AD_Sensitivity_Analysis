
.. _program_listing_file_include_microphysics_physical_parameterizations.h:

Program Listing for File physical_parameterizations.h
=====================================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_microphysics_physical_parameterizations.h>` (``include/microphysics/physical_parameterizations.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <algorithm>
   #include <cmath>
   
   #include <boost/math/special_functions/gamma.hpp>
   #include "codi.hpp"
   
   #include "include/microphysics/constants.h"
   #include "include/types/collection_model_constants_t.h"
   #include "include/types/input_parameters_t.h"
   #include "include/types/particle_model_constants_t.h"
   #include "include/types/reference_quantities_t.h"
   #include "include/types/table_t.h"
   
   
   template <class float_t>
   inline float_t polyval2(
       const double a0,
       const double a1,
       const double a2,
       float_t x) {
   
       return (a0 + x*(a1 + a2*x));
   }
   
   
   template <class float_t>
   inline float_t polyval4(
       const double a0,
       const double a1,
       const double a2,
       const double a3,
       const double a4,
       float_t x) {
   
       return (a0 + x*(a1 + x*(a2 + x*(a3 + x*a4))));
   }
   
   
   template <class float_t>
   inline float_t polyval5(
       const double a0,
       const double a1,
       const double a2,
       const double a3,
       const double a4,
       const double a5,
       float_t x) {
   
       return (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*a5)))));
   }
   
   
   template <class float_t>
   inline float_t polyval6(
       const double a0,
       const double a1,
       const double a2,
       const double a3,
       const double a4,
       const double a5,
       const double a6,
       float_t x) {
   
       return (a0 + x*(a1 + x*(a2 + x*(a3 + x*(a4 + x*(a5 + a6*x))))));
   }
   
   
   template <class float_t>
   inline float_t diffusivity(
       float_t T,
       float_t p) {
   
       return ((2.11e-5)*(101325.0/p)*pow(T/273.15 , 1.94));
   }
   
   
   template <class float_t>
   inline float_t thermal_conductivity_dry_air(float_t T) {
       // Change temperature to Celsius-scale
       float_t T_cel = T - 273.15;
       return (418.68*(5.75e-5)*polyval2(1.0, 0.00317, -0.0000021, T_cel));
   }
   
   
   template <class float_t>
   inline float_t thermal_conductivity_moist_air(
       float_t T,
       float_t qv,
       float_t Epsilon) {
   
       // Thermal conductivity dry air
       float_t Kt = thermal_conductivity_dry_air(T);
   
       float_t Kt_tilde = Kt/418.68;
       float_t Kv_tilde = (3.78e-5) + (2.0e-7)*(T - 273.15);
   
       return (Kt*(1.0 - (1.17 - 1.02*(Kt_tilde/Kv_tilde))*(qv/(qv+Epsilon))));
   }
   
   
   template <class float_t>
   inline float_t density_water(float_t T) {
       // Change to Celsius scale
       float_t T_cel = T - 273.15;
       float_t F_T;
       float_t denom;
       double a0, a1, a2, a3, a4, a5, a6;
   
       if (273.15 >= T) {
           // Parameterization from Hare and Sorensen (1987)
           a0 = 999.86;
           a1 = 6.69e-2;
           a2 = -8.486e-3;
           a3 = 1.518e-4;
           a4 = -6.9484e-6;
           a5 = -3.6449e-7;
           a6 = -7.497e-9;
   
           F_T = polyval6(a0, a1, a2, a3, a4, a5, a6, T_cel);
           denom = 1.0;
   
           } else {
           // Parameterization from Kell (1975)
   
           a0 = 999.8395;
           a1 = 16.945176;
           a2 = -7.9870401e-3;
           a3 = -46.170461e-6;
           a4 = 105.56302e-9;
           a5 = -280.54253e-12;
   
           F_T = polyval5(a0, a1, a2, a3, a4, a5, T_cel);
           denom = 1.0 + (16.87985e-3)*T_cel;
       }
       return (F_T/denom);
   }
   
   
   template <class float_t>
   inline float_t density_ice(float_t T) {
       float_t T_cel = T - 273.15;
       return polyval2(916.7, -0.175, -0.0005, T_cel);
   }
   
   
   template <class float_t>
   inline float_t specific_heat_dry_air(float_t T) {
       return cp;  // 1005.0
   }
   
   
   template <class float_t>
   inline float_t specific_heat_water_vapor(float_t T) {
       return 1884.06;
   }
   
   
   template <class float_t>
   inline float_t specific_heat_water(float_t T) {
       float_t T_cel = T - 273.15;
       double a0, a1, a2, a3, a4;
   
       if (273.15 > T) {
           a0 = 1.000983;
           a1 = -2.7052e-3;
           a2 = -2.3235e-5;
           a3 = 4.3778e-6;
           a4 = 2.7136e-7;
       } else {
           a0 = 0.9979;
           a1 = 0.0;
           a2 = 3.1e-6;
           a3 = 0.0;
           a4 = 3.8e-9;
       }
       return (4186.8*polyval4(a0, a1, a2, a3, a4, T_cel));
   }
   
   
   template <class float_t>
   inline float_t specific_heat_ice(float_t T, float_t M_w) {
       float_t T_frac = T/125.1;
       return ((-2.0572 + 0.14644*T + 0.06163*T*exp(-T_frac*T_frac))/M_w);
   }
   
   
   template <class float_t>
   inline float_t latent_heat_water_supercooled(float_t T, float_t M_w) {
       return ((56579.0 - 42.212*T + exp(0.1149*(281.6-T)))/M_w);
   }
   
   
   template <class float_t>
   inline float_t latent_heat_water(
       float_t T,
       float_t L_wd,
       float_t cv,
       float_t cp,
       float_t T_freeze,
       float_t R_v,
       float_t R_a) {
       // 4.1733*cp = liquid water heat capacity
       // cp - R_a = specific heat at constant volume
       return (L_wd + (cv - 4.1733*cp) * (T - T_freeze) - R_v * T) / (cp - R_a);
   }
   
   template <class float_t>
   inline float_t latent_heat_ice(float_t T, float_t M_w) {
       float_t T_frac = T/123.75;
       return ((polyval2(46782.5, 35.8925, -0.07414, T)
           + 541.5*exp(-T_frac*T_frac))/M_w);
   }
   
   
   template <class float_t>
   inline float_t latent_heat_melt(float_t T, float_t T_freeze) {
       // Table A1
       return 4.184e3 * (79.7+0.485*(T-T_freeze)
           - 2.5e-3*(T-T_freeze)*(T-T_freeze));
   }
   
   
   template <class float_t>
   inline float_t latent_heat_evap(float_t T) {
       // Table A1
       float_t lh_e0 = 2.5006e6;
       float_t gam = 0.167 + 3.67e-4 * T;
       return lh_e0 * pow(T_freeze/T, gam);
   }
   
   
   template <class float_t>
   inline float_t saturation_pressure_water(
       float_t T,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b) {
   #ifdef VANILLA_PRESSURE
       float_t Tinv = 1.0/T;
       float_t logT = log(T);
       return (exp(54.842763 - 6763.22*Tinv - 4.21*logT + 0.000367*T
           + tanh(0.0415*(T-218.8))*(53.878 - 1331.22*Tinv - 9.44523*logT + 0.014025*T)));
   #else
       return p_sat_low_temp
           * exp(p_sat_const_a * (T-T_sat_low_temp) / (T-p_sat_const_b));
   #endif
   }
   
   
   template <class float_t>
   inline float_t saturation_pressure_ice(
       float_t T,
       float_t p_sat_low_temp,
       float_t p_sat_ice_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_ice_const_b) {
   #ifdef VANILLA_PRESSURE
       return (exp(9.550426 - (5723.265/T) + 3.53068*log(T) - 0.00728332*T));
   #else
       return (p_sat_low_temp * exp(p_sat_ice_const_a
               * (T-T_sat_low_temp)
           / (T-p_sat_ice_const_b)));
   #endif
   }
   
   
   template <class float_t>
   inline float_t surface_tension_water(float_t T) {
       float_t T_cel = T - 273.15;
       double a0, a1, a2, a3, a4, a5, a6;
   
       a0 = 75.7901;
       a1 = -0.139649;
       a2 = -4.62016e-4;
       a3 = -2.92323e-5;
       a4 = 1.29287e-6;
       a5 = -1.70799e-8;
       a6 = 7.25066e-11;
   
       return (0.001*polyval6(a0, a1, a2, a3, a4, a5, a6, T_cel));
   }
   
   
   template <class float_t>
   inline float_t mean_free_path(
       float_t &p,
       float_t &T) {
   
       return ((6.6e-8)*(T/293.15)*(101325.0/p));
   }
   
   
   template <class float_t>
   inline float_t compute_pv(
       float_t T,
       float_t S,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b) {
   
       return (S*saturation_pressure_water(T, p_sat_low_temp, p_sat_const_a,
           T_sat_low_temp, p_sat_const_b));
   }
   
   
   template <class float_t>
   inline float_t compute_pa(
       float_t p,
       float_t T,
       float_t S,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b) {
   
       return (p - compute_pv(T, S, p_sat_low_temp, p_sat_const_a,
           T_sat_low_temp, p_sat_const_b));
   }
   
   
   template <class float_t>
   inline float_t compute_rhoa(
       float_t p,
       float_t T,
       float_t S,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b,
       float_t R_a) {
   
       return (compute_pa(p, T, S, p_sat_low_temp, p_sat_const_a,
           T_sat_low_temp, p_sat_const_b) / (R_a*T));
   }
   
   
   template <class float_t>
   inline float_t compute_rhoh(
       float_t p,
       float_t T,
       float_t S,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b,
       float_t R_a,
       float_t R_v) {
   
       return (compute_pa(p, T, S, p_sat_low_temp, p_sat_const_a,
           T_sat_low_temp, p_sat_const_b)
           / (R_a*T)
           + compute_pv(T, S, p_sat_low_temp, p_sat_const_a,
               T_sat_low_temp, p_sat_const_b)
           / (R_v*T));
   }
   
   template <class float_t>
   inline float_t convert_S_to_qv(float_t p,
       float_t T,
       float_t S,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b,
       float_t Epsilon) {
   // #ifdef B_EIGHT
   //     float_t r_d = 287.04;
   //     float_t r_v = 461.51;
   //     float_t qv_sat = r_d/r_v * saturation_pressure_water(
           // T, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b)
   //         / (p - (1-r_d/r_v)
   //             * saturation_pressure_water(
           // T, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b));
   //     return S*qv_sat*100.0;
   // #else
       return (Epsilon*(
           compute_pv(T, S, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b)
           / compute_pa(p, T, S, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b)));
   // #endif
   }
   
   
   template <class float_t>
   inline float_t convert_Si_to_qv(float_t p,
       float_t T,
       float_t Si,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b,
       float_t Epsilon,
       float_t p_sat_ice_const_a,
       float_t p_sat_ice_const_b) {
   
       float_t S = Si * (
           saturation_pressure_ice(T, p_sat_low_temp, p_sat_ice_const_a, T_sat_low_temp, p_sat_ice_const_b)
           / saturation_pressure_water(T, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b));
   
     return convert_S_to_qv(p, T, S, p_sat_low_temp, p_sat_const_a,
       T_sat_low_temp, p_sat_const_b, Epsilon);
   }
   
   
   template <class float_t>
   inline float_t convert_qv_to_S(
       float_t p,
       float_t T,
       float_t qv,
       float_t p_sat_low_temp,
       float_t p_sat_const_a,
       float_t T_sat_low_temp,
       float_t p_sat_const_b,
       float_t Epsilon) {
   // #ifdef B_EIGHT
   //     float_t r_d = 287.04;
   //     float_t r_v = 461.51;
   //     float_t qv_sat = r_d/r_v * saturation_pressure_water(
           // T, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b)
   //         / (p - (1-r_d/r_v)
   //             * saturation_pressure_water(
           // T, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b));
   //     return qv/qv_sat/100.0;
   // #else
       return ((p*qv)/((Epsilon + qv)
           * saturation_pressure_water(T, p_sat_low_temp, p_sat_const_a, T_sat_low_temp, p_sat_const_b)));
   // #endif
   }
   
   
   template <class float_t>
   inline float_t particle_mean_mass(
       const float_t &q,
       const float_t &n,
       const float_t &min_x,
       const float_t &max_x) {
   
       return min(max(q/(n+DBL_EPSILON), min_x), max_x);
   }
   
   
   template <class float_t>
   inline float_t particle_diameter(
       const float_t &x,
       const float_t &a_geo,
       const float_t &b_geo) {
   
       return a_geo * pow(x, b_geo);
   }
   
   template <class float_t>
   inline float_t particle_velocity(
       const float_t &x,
       const float_t &a_vel,
       const float_t &b_vel) {
   
       return a_vel * pow(x, b_vel);
   }
   
   template <class float_t>
   inline float_t rain_mue_dm_relation(
       const float_t &D_m,
       const float_t &cmu0,
       const float_t &cmu1,
       const float_t &cmu2,
       const float_t &cmu3,
       const float_t &cmu4) {
   
       float_t delta = cmu2*(D_m-cmu3);
       if (D_m <= cmu3)
           return cmu0*tanh(16.0*delta*delta) + cmu4;
       return cmu1*tanh(delta*delta) + cmu4;
   }
   
   template <class float_t>
   inline float_t rain_mue_dm_relation_sb(
       const float_t &D_m,
       const float_t &cmu0,
       const float_t &cmu1,
       const float_t &cmu2,
       const float_t &cmu3,
       const float_t &cmu4) {
   
       float_t delta = D_m-cmu3;
       if (D_m <= cmu3)
           return cmu0*tanh(4.0e-3*delta)*tanh(4.0*delta) + cmu4;
       return cmu1*tanh(1e-3*delta)*tanh(1e-3*delta) + cmu4;
   }
   
   
   template <class float_t>
   float_t wet_growth_diam(
       const float_t &p,
       const float_t &T,
       const float_t &qw,
       const float_t &qi,
       const table_t<float_t> &table);
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_delta(
       particle_model_constants_t<float_t> &pc1,
       const uint64_t n) {
   
       float_t tmp1 = (2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)
           + get_at(pc1.constants, Particle_cons_idx::nu)+1.0+n)
           / get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp2 = (get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp3 = (get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp4 = (get_at(pc1.constants, Particle_cons_idx::nu)+2.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       return tgamma(tmp1)
           / tgamma(tmp2)
           * pow(tgamma(tmp3), 2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)+n)
           / pow(tgamma(tmp4), 2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)+n);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_delta_11(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       const uint64_t n) {
   
       return coll_delta<float_t>(pc1, n);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_delta_22(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       const uint64_t n) {
   
       return coll_delta<float_t>(pc2, n);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_delta_12(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       const uint64_t n) {
   
       float_t tmp1 = (get_at(pc1.constants, Particle_cons_idx::b_geo)+get_at(pc1.constants, Particle_cons_idx::nu)+1.0)
           / get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp2 = (get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp3 = (get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp4 = (get_at(pc1.constants, Particle_cons_idx::nu)+2.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t res =  2.0 * tgamma(tmp1)
           / tgamma(tmp2)
           * pow(tgamma(tmp3), get_at(pc1.constants, Particle_cons_idx::b_geo))
           / pow(tgamma(tmp4), get_at(pc1.constants, Particle_cons_idx::b_geo));
       tmp1 = (get_at(pc2.constants, Particle_cons_idx::b_geo)+get_at(pc2.constants, Particle_cons_idx::nu)+1.0+n)
           / get_at(pc2.constants, Particle_cons_idx::mu);
       tmp2 = (get_at(pc2.constants, Particle_cons_idx::nu)+1.0)/get_at(pc2.constants, Particle_cons_idx::mu);
       tmp3 = (get_at(pc2.constants, Particle_cons_idx::nu)+1.0)/get_at(pc2.constants, Particle_cons_idx::mu);
       tmp4 = (get_at(pc2.constants, Particle_cons_idx::nu)+2.0)/get_at(pc2.constants, Particle_cons_idx::mu);
       return res * tgamma(tmp1)
           / tgamma(tmp2)
           * pow(tgamma(tmp3), get_at(pc2.constants, Particle_cons_idx::b_geo)+n)
           / pow(tgamma(tmp4), get_at(pc2.constants, Particle_cons_idx::b_geo)+n);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_theta(
       particle_model_constants_t<float_t> &pc1,
       const uint64_t n) {
   
       float_t tmp1 = (2.0*get_at(pc1.constants, Particle_cons_idx::b_vel)
           + 2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)
           + get_at(pc1.constants, Particle_cons_idx::nu)+1.0+n)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp2 = (2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)
           + get_at(pc1.constants, Particle_cons_idx::nu)+1.0+n)
           / get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp3 = (get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp4 = (get_at(pc1.constants, Particle_cons_idx::nu)+2.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       return tgamma(tmp1)
           / tgamma(tmp2)
           * pow(tgamma(tmp3), 2.0*get_at(pc1.constants, Particle_cons_idx::b_vel))
           / pow(tgamma(tmp4), 2.0*get_at(pc1.constants, Particle_cons_idx::b_vel));
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_theta_11(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       const uint64_t n) {
   
       return coll_theta<float_t>(pc1, n);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_theta_22(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       const uint64_t n) {
   
       return coll_theta<float_t>(pc2, n);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t coll_theta_12(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       const uint64_t n) {
   
       float_t tmp1 = (get_at(pc1.constants, Particle_cons_idx::b_vel)+2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)
           + get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp2 = (2.0*get_at(pc1.constants, Particle_cons_idx::b_geo)
           + get_at(pc1.constants, Particle_cons_idx::nu)+1.0)
           / get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp3 = (get_at(pc1.constants, Particle_cons_idx::nu)+1.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t tmp4 = (get_at(pc1.constants, Particle_cons_idx::nu)+2.0)/get_at(pc1.constants, Particle_cons_idx::mu);
       float_t res = 2.0 * tgamma(tmp1)
           / tgamma(tmp2)
           * pow(tgamma(tmp3), get_at(pc1.constants, Particle_cons_idx::b_vel))
           / pow(tgamma(tmp4), get_at(pc1.constants, Particle_cons_idx::b_vel));
       tmp1 = (get_at(pc2.constants, Particle_cons_idx::b_vel)+2.0*get_at(pc2.constants, Particle_cons_idx::b_geo)
           + get_at(pc2.constants, Particle_cons_idx::nu)+1.0+n)/get_at(pc2.constants, Particle_cons_idx::mu);
       tmp2 = (2.0*get_at(pc2.constants, Particle_cons_idx::b_geo)+get_at(pc2.constants, Particle_cons_idx::nu)+1.0+n)
           / get_at(pc2.constants, Particle_cons_idx::mu);
       tmp3 = (get_at(pc2.constants, Particle_cons_idx::nu)+1.0)/get_at(pc2.constants, Particle_cons_idx::mu);
       tmp4 = (get_at(pc2.constants, Particle_cons_idx::nu)+2.0)/get_at(pc2.constants, Particle_cons_idx::mu);
       return res * tgamma(tmp1)
           / tgamma(tmp2)
           * pow(tgamma(tmp3), get_at(pc2.constants, Particle_cons_idx::b_vel))
           / pow(tgamma(tmp4), get_at(pc2.constants, Particle_cons_idx::b_vel));
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t vent_coeff_a(
       particle_model_constants_t<float_t> &pc,
       uint64_t n) {
   
       return get_at(pc.constants, Particle_cons_idx::a_ven)
           * tgamma((get_at(pc.constants, Particle_cons_idx::nu)+n
           + get_at(pc.constants, Particle_cons_idx::b_geo))/get_at(pc.constants, Particle_cons_idx::mu))
           / tgamma((get_at(pc.constants, Particle_cons_idx::nu)+1.0)/get_at(pc.constants, Particle_cons_idx::mu))
           * pow(tgamma((get_at(pc.constants, Particle_cons_idx::nu)+1.0)
           / get_at(pc.constants, Particle_cons_idx::mu)) / tgamma((get_at(pc.constants, Particle_cons_idx::nu)+2.0)
           / get_at(pc.constants, Particle_cons_idx::mu)), get_at(pc.constants, Particle_cons_idx::b_geo)+n-1.0);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t vent_coeff_b(
       particle_model_constants_t<float_t> &pc,
       uint64_t n) {
   
       const double m_f = 0.5;  // From PK, page 541
       return get_at(pc.constants, Particle_cons_idx::b_ven)
           * tgamma((get_at(pc.constants, Particle_cons_idx::nu)+n+(m_f+1.0)
           * get_at(pc.constants, Particle_cons_idx::b_geo)+m_f
           * get_at(pc.constants, Particle_cons_idx::b_vel))/get_at(pc.constants, Particle_cons_idx::mu))
           / tgamma((get_at(pc.constants, Particle_cons_idx::nu)+1.0)/get_at(pc.constants, Particle_cons_idx::mu))
           * pow(tgamma((get_at(pc.constants, Particle_cons_idx::nu)+1.0)/get_at(pc.constants, Particle_cons_idx::mu))
           / tgamma((get_at(pc.constants, Particle_cons_idx::nu)+2.0)
           / get_at(pc.constants, Particle_cons_idx::mu)), (m_f+1.0) * get_at(pc.constants, Particle_cons_idx::b_geo)
           + m_f*get_at(pc.constants, Particle_cons_idx::b_vel)+n-1.0);
   }
   
   
   template <class float_t = codi::RealReverse>
   inline float_t moment_gamma(
       particle_model_constants_t<float_t> &pc,
       uint64_t n) {
       return tgamma((n+get_at(pc.constants, Particle_cons_idx::nu)+1.0)
           / get_at(pc.constants, Particle_cons_idx::mu))
           / tgamma((get_at(pc.constants, Particle_cons_idx::nu)+1.0)/get_at(pc.constants, Particle_cons_idx::mu))
           * pow(tgamma((get_at(pc.constants, Particle_cons_idx::nu)+1.0)
           / get_at(pc.constants, Particle_cons_idx::mu))
           / tgamma((get_at(pc.constants, Particle_cons_idx::nu)+2.0)/get_at(pc.constants, Particle_cons_idx::mu)), n);
   }
   
   
   template<class float_t = codi::RealReverse>
   void setup_bulk_sedi(
       particle_model_constants_t<float_t> &pc);
   
   template<class float_t = codi::RealReverse>
   void init_particle_collection_1(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       collection_model_constants_t<float_t> &c);
   
   template<class float_t = codi::RealReverse>
   void init_particle_collection_2(
       particle_model_constants_t<float_t> &pc1,
       particle_model_constants_t<float_t> &pc2,
       collection_model_constants_t<float_t> &c);
     // end of group parametrizations
