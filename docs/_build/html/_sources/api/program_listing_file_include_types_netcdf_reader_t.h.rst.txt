
.. _program_listing_file_include_types_netcdf_reader_t.h:

Program Listing for File netcdf_reader_t.h
==========================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_types_netcdf_reader_t.h>` (``include/types/netcdf_reader_t.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #include <netcdf.h>
   #include <netcdf_par.h>
   
   #include <array>
   #include <vector>
   
   #include "codi.hpp"
   
   #include "include/misc/error.h"
   #include "include/types/model_constants_t.h"
   #include "include/types/reference_quantities_t.h"
   
   struct netcdf_reader_t {
       uint64_t n_ensembles;
       uint64_t n_trajectories;
       // double dlon, dlat;
       bool start_time_idx_given; 
       uint64_t start_time_idx; 
       uint64_t start_time_idx_original; 
       uint64_t time_idx; 
       explicit netcdf_reader_t(const uint32_t &buffer_size);
   
       template<class float_t>
       int read_buffer(
           model_constants_t<float_t> &cc,
           const reference_quantities_t &ref_quant,
           std::vector<float_t> &y_single_old,
           std::vector<float_t> &inflows,
           const uint32_t &step,
           const bool &checkpoint_flag,
           const bool &start_over_env);
   
       template<class float_t>
       void set_dims(
           const char *input_file,
           model_constants_t<float_t> &cc,
           const int &simulation_mode);
   
       template<class float_t>
       void init_netcdf(
   #ifdef MET3D
           double &start_time,
   #endif
           const char *input_file,
           const bool &checkpoint_flag,
           model_constants_t<float_t> &cc,
           const int &simulation_mode,
           const double current_time,
           const reference_quantities_t &ref_quant);
   
       template<class float_t>
       void read_initial_values(
           std::vector<double> &y_init,
           const reference_quantities_t &ref_quant,
           model_constants_t<float_t> &cc,
           const bool &checkpoint_flag,
           const uint64_t &traj_id,
           const uint64_t &ens_id);
       template<class float_t>
       void read_initial_values(
           std::vector<double> &y_init,
           const reference_quantities_t &ref_quant,
           model_constants_t<float_t> &cc,
           const bool &checkpoint_flag);
   
       double get_lat(const uint32_t &t, const uint32_t &sub) const;
       double get_lon(const uint32_t &t, const uint32_t &sub) const;
   #if defined(MET3D) || defined(B_EIGHT)
       double get_relative_time(const uint32_t &t) const {
           return buffer[Par_idx::time_after_ascent][t%buffer[Par_idx::time_after_ascent].size()];
       }
   #if !defined(B_EIGHT)
       bool get_conv_400(const uint32_t &t) const {return (buffer[Par_idx::conv_400][
           t%buffer[Par_idx::conv_400].size()] > 0.5);}
       bool get_conv_600(const uint32_t &t) const {return (buffer[Par_idx::conv_600][
           t%buffer[Par_idx::conv_600].size()] > 0.5);}
       bool get_slan_400(const uint32_t &t) const {return (buffer[Par_idx::slan_400][
           t%buffer[Par_idx::slan_400].size()] > 0.5);}
       bool get_slan_600(const uint32_t &t) const {return (buffer[Par_idx::slan_600][
           t%buffer[Par_idx::slan_600].size()] > 0.5);}
   #endif
   
   #endif
       uint32_t get_traj_idx() const {return traj_idx;}
   
    private:
       std::vector<int> startp, countp;
       int ncid;
       uint64_t n_timesteps_in; 
       uint32_t n_timesteps_buffer; 
       uint64_t time_buffer_idx; 
       uint32_t traj_idx; 
       uint32_t ens_idx; 
       bool already_open; 
       uint32_t n_subs; 
       double pascal_conv; 
       std::vector<int> dimid;
       std::vector<int> varid, varid_once;
   
       enum Par_idx {
           pressure,
           temperature,
           ascent,
           lat,
           lon,
   #if defined(FLUX) && !defined(WCB)
           qr_in,
           nr_in,
       #if defined(RK4ICE)
           qi_in,
           qs_in,
           qg_in,
       #if defined(B_EIGHT)
           qh_in,
       #endif
           ni_in,
           ns_in,
           ng_in,
       #if defined(B_EIGHT)
           nh_in,
       #endif
       #endif
   #endif
           height,
   #ifdef MET3D
           time_after_ascent,
           conv_400,  // might make trouble type wise
           conv_600,
           slan_400,
           slan_600,
       #ifdef TURBULENCE
           q_turb,
       #endif
   #endif
           n_pars
       };
       enum Dim_idx {
           time_dim_idx,
           trajectory_dim_idx,
   #if !defined(B_EIGHT)
           ensemble_dim_idx,
   #endif
           n_dims
       };
       // Index for variable ids that are read during initialization
       enum Par_once_idx {
           qv,
           qc,
           qr,
   #if defined(RK4ICE)
           qi,
           qs,
           qg,
       #if defined(B_EIGHT)
           qh,
       #endif
           nc,
           nr,
           ni,
           ns,
           ng,
       #if defined(B_EIGHT)
           nh,
       #endif
   #endif
           time,
           n_pars_once
       };
   
       std::array<std::vector<double>, Par_idx::n_pars > buffer;
   
       void load_vars();
   
       void buffer_params(const reference_quantities_t &ref_quant);
   };
