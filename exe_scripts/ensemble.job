#!/bin/bash
#SBATCH --job-name=wcb_ensemble
#SBATCH --output=logs/wcb_ensemble_%A.out
#SBATCH --error=logs/wcb_ensemble_%A.err
#SBATCH --time=2:30:00
#SBATCH -p parallel
#SBATCH --nodes=1
#SBATCH --ntasks=32
#SBATCH -A m2_zdvresearch
#SBATCH --mem-per-cpu=1500
#SBATCH -C skylake
#SBATCH --signal=B:SIGUSR2@300 # e.g. signal 5 minutes before the job will end
                               # time, here, is defined in seconds.
module purge
module load tools/parallel/20181122
module load numlib/GSL/2.5-GCCcore-6.4.0
module load data/netCDF-C++4/4.3.0-foss-2018a
module load devel/Boost/1.68.0-foss-2018a

# Store working directory to be safe
cd ..
SAVEDPWD=$(pwd)
export AD_SIM_HOME=/localscratch/${SLURM_JOB_ID}
SUFF="config_ens_separate"

NEW_CHECKPOINTS=${AD_SIM_HOME}/tmp/${SUFF}

if [ ! -d "$NEW_CHECKPOINTS" ]
then
    mkdir -p "$NEW_CHECKPOINTS"
fi
# Folder name to find the results later again

SAVE_INPUTFILENAME="/lustre/project/m2_zdvresearch/mahieron/netcdf_vladiana_stats/no_exclusions_conv_400_median.nc_wcb"
INPUT_FILENAME="${AD_SIM_HOME}/data/no_exclusions_conv_400_median.nc_wcb"
SAVE_OUTPUTPATH="/lustre/project/m2_zdvresearch/mahieron/perturbed_ensembles/${SUFF}/"
OUTPUT_PATH="${AD_SIM_HOME}/output/${SUFF}/"
SAVE_ENSEMBLECONFIG="${SAVEDPWD}/configs/config_ens_separate.json"
ENSEMBLE_CONFIG="${AD_SIM_HOME}/configs/config_ens_separate.json"

# We define a bash function to do the cleaning when the signal is caught
cleanup(){
    # Note: The following only works on single with output on the node,
    #       where the jobscript is running.
    if [ ! -d "${SAVE_OUTPUTPATH}" ]
    then
        mkdir -p "${SAVE_OUTPUTPATH}"
    fi
    echo "copying from ${OUTPUT_PATH}* to ${SAVE_OUTPUTPATH}"
    find ${OUTPUT_PATH} -type f -name "*.nc_wcb" -exec cp {} ${SAVE_OUTPUTPATH} \; &
    wait
    exit 0
}

# Register the cleanup function when SIGUSR2 is sent,
# ten minutes before the job gets killed
trap 'cleanup' SIGUSR2

# Copy executable, input file, configuration file
# Create directories for temporary files, output data
if [ ! -d "${AD_SIM_HOME}/build/apps/src/microphysics/" ]
then
    mkdir -p "${AD_SIM_HOME}/build/apps/src/microphysics/"
fi
cp ${SAVEDPWD}/build/apps/src/microphysics/trajectories ${AD_SIM_HOME}/build/apps/src/microphysics/

if [ ! -d "${AD_SIM_HOME}/data/" ]
then
    mkdir -p "${AD_SIM_HOME}/data/"
fi
cp ${SAVE_INPUTFILENAME} ${AD_SIM_HOME}/data/

if [ ! -d "${AD_SIM_HOME}/tmp/" ]
then
    mkdir -p "${AD_SIM_HOME}/tmp/"
fi

if [ ! -d "${OUTPUT_PATH}" ]
then
    mkdir -p "${OUTPUT_PATH}"
fi

if [ ! -d "${AD_SIM_HOME}/configs/" ]
then
    mkdir -p "${AD_SIM_HOME}/configs/"
fi
cp ${SAVE_ENSEMBLECONFIG} ${ENSEMBLE_CONFIG}

cp ${SAVEDPWD}/dmin_wetgrowth_lookup.dat ${AD_SIM_HOME}/

# Environmental conditions
SCALING_FACTOR="1.0"
AUTO_TYPE="3"
TIMESTEP="20"

# Output variables
PROGRESSBAR="0"
START_TIME="-2800"
WRITE_INDEX="1000"
SNAPSHOT_INDEX="1"
TARGET_TIME_AFTER_START="26000"

# Operational variables
START_OVER="0"
START_OVER_ENVIRONMENT="1"
FIXED_ITERATION="0"

cd ${AD_SIM_HOME}

${AD_SIM_HOME}/build/apps/src/microphysics/./trajectories -w ${WRITE_INDEX} -a ${AUTO_TYPE} \
-t ${FIXED_ITERATION} -s ${START_OVER} -f ${TARGET_TIME_AFTER_START} -d ${TIMESTEP} \
-i ${SNAPSHOT_INDEX} -b ${SCALING_FACTOR} \
-o ${OUTPUT_PATH}"wcb${TARGET_TIME_AFTER_START}_traj0_MAP_t000000_p001" \
-e ${START_OVER_ENVIRONMENT} \
-p ${PROGRESSBAR} \
-n ${START_TIME} \
-l ${INPUT_FILENAME} -r 0 -g 0 \
-m ${ENSEMBLE_CONFIG} \
-h ${NEW_CHECKPOINTS}

declare -a arr_files
declare -a old_files

array_not_contains () {
    local array="$1[@]"
    local seeking=$2
    local in=0
    for element in "${!array}"; do
        if [[ $element == "$seeking" ]]; then
            in=1
            break
        fi
    done
    return $in
}

while true
do
    for entry in "${NEW_CHECKPOINTS}/execute_id*"
    do
        array_not_contains old_files ${entry} && arr_files=("${arr_files[@]}" "$entry")
    done
    if [ ${#arr_files[@]} == 0 ]
    then
        break
    fi
    for entry in ${arr_files[@]}
    do
        /bin/bash ${entry}
        old_files=("${old_files[@]}" "$entry")
    done
    unset arr_files
done

# Call the cleanup function when everything went fine
cleanup
